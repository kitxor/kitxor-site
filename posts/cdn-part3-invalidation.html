<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CDN Design Part 3: Cache Invalidation Strategies ~ kitxor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background: #ffffff;
            color: #000000;
            padding: 30px 20px;
            line-height: 1.5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .back-link {
            color: #0066cc;
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 20px;
            display: inline-block;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .back-link::before {
            content: '← ';
        }

        .post-header {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #000000;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            color: #000000;
        }

        .post-meta {
            color: #666666;
            font-size: 0.85rem;
        }

        .content {
            color: #000000;
        }

        h2 {
            color: #000000;
            font-size: 1.5rem;
            margin-top: 30px;
            margin-bottom: 12px;
            border-left: 3px solid #000000;
            padding-left: 10px;
        }

        h3 {
            color: #000000;
            font-size: 1.2rem;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 12px;
        }

        code {
            background: #f0f0f0;
            color: #000000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9rem;
        }

        pre {
            background: #f9f9f9;
            border: 1px solid #cccccc;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }

        pre code {
            background: none;
            padding: 0;
            color: #000000;
            display: block;
        }

        ul, ol {
            margin: 12px 0;
            padding-left: 40px;
        }

        li {
            margin-bottom: 6px;
        }

        a {
            color: #0066cc;
            text-decoration: underline;
        }

        a:hover {
            color: #004499;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: #f9f9f9;
            font-size: 0.85rem;
        }

        th, td {
            border: 1px solid #cccccc;
            padding: 10px;
            text-align: left;
        }

        th {
            background: #000000;
            color: #ffffff;
            font-weight: bold;
        }

        @media (max-width: 600px) {
            body {
                padding: 20px 15px;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.3rem;
            }

            table {
                font-size: 0.75rem;
            }

            th, td {
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">back to home</a>

        <div class="post-header">
            <h1>CDN Design Part 3: Cache Invalidation Strategies</h1>
            <div class="post-meta">2026-01-04 | system design, cdn, caching</div>
        </div>

        <div class="content">
            <p>You've deployed a CDN. Your homepage HTML is cached on 200 edge servers across 50 countries. At 9 AM, marketing pushes a critical update: Black Friday sale goes live. How do you ensure a billion users see the new page, not the stale cached version from yesterday?</p>

            <h2>The Problem</h2>

            <p>200 edge servers, no shared memory. When origin updates content, edges don't know. Strong consistency requires coordinating all edges (kills availability). Invalidating everything triggers cache miss storm - all edges fetch simultaneously, origin gets 200x traffic spike. Can't have consistency + availability + performance simultaneously.</p>

            <h2>Four Invalidation Strategies</h2>

            <h3>1. TTL (Time-to-Live)</h3>

            <p>Origin sets expiration time via <code>Cache-Control: max-age=3600</code>. Edge caches until TTL expires, then fetches fresh version. Update at 10 AM with 1-hour TTL = users see old version until 11 AM.</p>

            <p><strong>Key points:</strong> Simple (set header, forget). No coordination overhead. Guaranteed staleness window. Can't force immediate updates. Trade-off: short TTL = more origin load, long TTL = longer staleness.</p>

            <h3>2. Purge (Explicit Invalidation)</h3>

            <p>API call deletes URL from all edges. Next request = cache miss → fetch from origin. All edges fetch simultaneously = origin storm.</p>

            <pre><code>10:01 AM: Call purge API for homepage.html
10:02 AM: All 200 edges delete cache
10:03 AM: 1M requests → 1M cache misses → origin gets 1M req/sec → dead</code></pre>

            <p><strong>Key points:</strong> Immediate consistency. Full control. Cache miss storm risk - origin must handle 200x spike. Manual intervention. Propagation delay (5-30 seconds).</p>

            <h3>3. Versioned URLs</h3>

            <p>Include version in URL: <code>style.css?v=2</code> or <code>style.abc123.css</code>. Update = new URL. Old URL stays cached, new URL fresh. No invalidation needed.</p>

            <pre><code>Old: style.css?v=1 (cached)
New: style.css?v=2 (fresh fetch)
Update HTML to reference v=2. No purge. No storm.</code></pre>

            <p><strong>Key points:</strong> Zero invalidation overhead. Immutable caching (cache forever). Safe rollbacks. Requires build system changes. Doesn't work for HTML entry points.</p>

            <h3>4. Soft Purge / Stale-While-Revalidate</h3>

            <p>Mark content stale, keep serving it. Fetch fresh version in background asynchronously. Next request gets updated content.</p>

            <pre><code>Cache-Control: max-age=3600, stale-while-revalidate=86400
After 1 hour: serve stale, fetch fresh in background

10:02 AM: User requests → edge serves OLD (instant)
          → edge fetches NEW in background (async)
10:03 AM: Next user gets NEW
Staleness window: 1 request (~1 minute)</code></pre>

            <p><strong>Key points:</strong> No cache miss (instant response always). No origin storm (background fetches spread out). Best performance. Temporary inconsistency (1 request sees stale). Not for critical updates.</p>

            <h2>Trade-offs Table</h2>

            <table>
                <thead>
                    <tr>
                        <th>Strategy</th>
                        <th>Consistency</th>
                        <th>Performance</th>
                        <th>Complexity</th>
                        <th>Cost</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>TTL</td>
                        <td>Weak (stale until expiry)</td>
                        <td>High (no misses)</td>
                        <td>Low (set header)</td>
                        <td>Low</td>
                    </tr>
                    <tr>
                        <td>Purge</td>
                        <td>Strong (immediate)</td>
                        <td>Low (miss storm)</td>
                        <td>Medium (API calls)</td>
                        <td>High (origin load)</td>
                    </tr>
                    <tr>
                        <td>Versioned URLs</td>
                        <td>Strong (new URL)</td>
                        <td>High (no misses)</td>
                        <td>High (app changes)</td>
                        <td>Low</td>
                    </tr>
                    <tr>
                        <td>Soft Purge</td>
                        <td>Eventual (1 request delay)</td>
                        <td>Highest (serve stale)</td>
                        <td>Medium (CDN support)</td>
                        <td>Low</td>
                    </tr>
                </tbody>
            </table>

            <h2>When to Use What</h2>

            <p><strong>TTL (default):</strong> User profile images, like counts, blog posts. Staleness acceptable, eventual consistency fine.</p>

            <p><strong>Purge:</strong> Low traffic content, urgent fixes (security patches), strong origin capacity, legal requirements (GDPR).</p>

            <p><strong>Versioned URLs:</strong> High traffic assets (CSS, JS), immutable content, build-time assets (webpack, vite). SPAs, modern web apps.</p>

            <p><strong>Soft Purge:</strong> High traffic pages with tolerable staleness (homepage, product pages). News sites, dashboards. Performance + freshness, not critical consistency.</p>

            <h2>Conclusion</h2>

            <p>Default to TTL + versioned URLs. TTL handles 80% (set expiration, forget). Versioned URLs solve 20% (immediate updates, no overhead). Reserve purge for emergencies. Soft purge for high-traffic tolerable staleness. Worst choice: manual purges for routine updates. Pick consistency guarantees upfront: strong (financial) → short TTL + purge; eventual (social) → long TTL; immutable (assets) → cache forever.</p>

            <div style="margin-top: 40px; padding-top: 15px; border-top: 2px solid #000000; text-align: center;">
                <a href="../index.html" class="back-link">back to all posts</a>
            </div>
        </div>
    </div>
</body>
</html>
