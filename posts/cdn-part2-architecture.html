<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CDN Design Part 2: Architecture & Caching Strategies ~ kitxor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', Courier, monospace;
            background: #ffffff;
            color: #000000;
            padding: 30px 20px;
            line-height: 1.5;
        }

        .container {
            max-width: 800px;
            margin: 0 auto;
        }

        .back-link {
            color: #0066cc;
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 20px;
            display: inline-block;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .back-link::before {
            content: '← ';
        }

        .post-header {
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #000000;
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 8px;
            color: #000000;
        }

        .post-meta {
            color: #666666;
            font-size: 0.85rem;
        }

        .updates {
            color: #888888;
            font-size: 0.75rem;
            margin-top: 4px;
            font-style: italic;
        }

        .content {
            color: #000000;
        }

        h2 {
            color: #000000;
            font-size: 1.5rem;
            margin-top: 30px;
            margin-bottom: 12px;
            border-left: 3px solid #000000;
            padding-left: 10px;
        }

        h3 {
            color: #000000;
            font-size: 1.2rem;
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 12px;
        }

        code {
            background: #f0f0f0;
            color: #000000;
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 0.9rem;
        }

        pre {
            background: #f9f9f9;
            border: 1px solid #cccccc;
            border-radius: 4px;
            padding: 15px;
            overflow-x: auto;
            margin: 15px 0;
        }

        pre code {
            background: none;
            padding: 0;
            color: #000000;
            display: block;
        }

        ul, ol {
            margin: 12px 0;
            padding-left: 40px;
        }

        li {
            margin-bottom: 6px;
        }

        a {
            color: #0066cc;
            text-decoration: underline;
        }

        a:hover {
            color: #004499;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            background: #f9f9f9;
            font-size: 0.85rem;
        }

        th, td {
            border: 1px solid #cccccc;
            padding: 10px;
            text-align: left;
        }

        th {
            background: #000000;
            color: #ffffff;
            font-weight: bold;
        }

        @media (max-width: 600px) {
            body {
                padding: 20px 15px;
            }

            h1 {
                font-size: 1.5rem;
            }

            h2 {
                font-size: 1.3rem;
            }

            table {
                font-size: 0.75rem;
            }

            th, td {
                padding: 6px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="../index.html" class="back-link">back to home</a>

        <div class="post-header">
            <h1>CDN Design Part 2: Architecture & Caching Strategies</h1>
            <div class="post-meta">2026-01-02 | system design, cdn, networking</div>
            <div class="updates">updates: 2026-01-04</div>
        </div>

        <div class="content">
            <p>Part 1 covered what CDNs are and why you need them. Part 2 covers how they actually work: request flow, multi-tier architecture, and caching decisions.</p>

            <h2>Request Flow</h2>

            <h3>Cache HIT (Fast Path)</h3>
            <pre><code>User requests cdn.example.com/logo.png
Assume: User ↔ Edge RTT = 30ms

1. DNS lookup - 30ms (1 RTT)
   User → DNS: query                                 [15ms]
   DNS → User: edge IP                               [15ms]

2. User ↔ Edge: TCP handshake - 45ms (1.5 RTT)
   User → Edge: SYN                                   [15ms]
   Edge → User: SYN-ACK                              [15ms]
   User → Edge: ACK                                   [15ms]

3. User ↔ Edge: TLS handshake - 30ms (1 RTT, TLS 1.3)
   User → Edge: ClientHello                          [15ms]
   Edge → User: ServerHello + cert                   [15ms]

4. HTTP request + cache hit - 16ms
   User → Edge: GET /logo.png                        [15ms]
   Edge checks cache → HIT                           [1ms local]

5. Edge → User: HTTP response - 15ms
   Edge → User: 200 OK + image data                  [15ms]

Total: ~136ms</code></pre>

            <h3>Cache MISS (Slow Path)</h3>
            <pre><code>User requests cdn.example.com/video.mp4
Assume: User ↔ Edge RTT = 30ms, Edge ↔ Origin RTT = 200ms (cross-continent)

1. DNS lookup - 30ms (1 RTT)
   User → DNS: query                                 [15ms]
   DNS → User: edge IP                               [15ms]

2. User ↔ Edge: TCP handshake - 45ms (1.5 RTT)
   User → Edge: SYN                                   [15ms]
   Edge → User: SYN-ACK                              [15ms]
   User → Edge: ACK                                   [15ms]

3. User ↔ Edge: TLS handshake - 30ms (1 RTT, TLS 1.3)
   User → Edge: ClientHello                          [15ms]
   Edge → User: ServerHello + cert                   [15ms]

4. User → Edge: HTTP request - 16ms
   User → Edge: GET /video.mp4                       [15ms]
   Edge checks cache → MISS                          [1ms local]

5. Edge ↔ Origin: TCP handshake - 300ms (1.5 RTT)
   Edge → Origin: SYN                                 [100ms]
   Origin → Edge: SYN-ACK                            [100ms]
   Edge → Origin: ACK                                 [100ms]

6. Edge ↔ Origin: TLS handshake - 200ms (1 RTT)
   Edge → Origin: ClientHello                        [100ms]
   Origin → Edge: ServerHello + cert                 [100ms]

7. Edge → Origin: HTTP request + response - 410ms
   Edge → Origin: GET /video.mp4                     [100ms]
   Origin processes request                          [10ms]
   Origin → Edge: 200 OK + 10MB video data           [100ms + 200ms transfer]

8. Edge writes to cache - 5ms local

9. Edge → User: HTTP response - 115ms
   Edge → User: 200 OK + video data                  [15ms + 100ms transfer]

First request total: ~1,151ms
Subsequent requests: ~136ms (steps 1-4 only, cache HIT)</code></pre>

            <h3>Flow Diagram</h3>
            <pre><code>User → DNS → Edge Server
         ├─ Cache HIT (~136ms)
         └─ Cache MISS → Parent CDN
                     ├─ Cache HIT (~600ms)
                     └─ Cache MISS → Origin (~1,151ms)</code></pre>

            <h2>Multi-Tier Architecture</h2>

            <h3>Why Multiple Tiers?</h3>
            <p><strong>Single-tier problem:</strong> 200 edges miss simultaneously → 200 parallel requests slam origin → dead.</p>

            <p><strong>Multi-tier solution:</strong> 200 child edges → 10 parent CDNs. Parents de-duplicate → 10 requests to origin (not 200). <strong>95% origin load reduction.</strong> Parent tier called <strong>Origin Shield</strong> (AWS/Cloudflare).</p>

            <h3>Math</h3>
            <pre><code>1M requests/day:
├─ Child hit (90%): 900K served from edge
├─ Parent hit (85% of 10%): 85K served from parent
└─ Origin hit: 15K (1.5% of total)

Without parent: 100K origin requests
With parent: 15K origin requests
Reduction: 85%</code></pre>

            <h3>The Three Tiers</h3>
            <p><strong>Child CDN (Edge):</strong> 200+ globally (CloudFront 450+). 1-10 TB storage. Hot content (top 10-20%). 85-95% hit ratio.</p>

            <p><strong>Parent CDN (Origin Shield):</strong> 10-20 globally (AWS has 13). 50-500 TB storage. Long tail content. 80-90% hit ratio on child misses.</p>

            <p><strong>Origin:</strong> 1 server/cluster. Unlimited storage. Gets hit only on double miss (~1-2% of total).</p>

            <h2>Edge Server Selection</h2>

            <p><strong>DNS-Based Geo-Routing:</strong> User queries DNS → GeoIP maps IP to location → returns nearest edge IP. "Nearest" = geographic distance + network topology + measured latency + server load.</p>

            <p><strong>DNS TTL problem:</strong> DNS cached 60-300s. Edge dies → users hit dead edge until TTL expires. Trade-off: lower TTL = faster failover, more DNS queries.</p>

            <p><strong>Anycast (alternative):</strong> Multiple edges share same IP (1.1.1.1). BGP routes to nearest. Faster failover, no DNS delay. Used by Cloudflare, Google.</p>

            <p><strong>Health checks:</strong> CDN pings edges. Dead server removed from DNS pool. Existing cached DNS still affected (TTL delay).</p>

            <h2>Caching Strategies: Pull vs Push</h2>

            <p><strong>Pull (Lazy):</strong> Fetch on-demand. Edge starts empty → cache miss → fetch from origin → cache locally. Efficient storage, scales to unlimited catalog. First request slow, origin sees more traffic. Best for: long tail, user-generated content.</p>

            <p><strong>Push (Proactive):</strong> Pre-position content. Origin pushes to all edges before requests. Zero latency, predictable. Wastes storage/bandwidth on unpopular content. Best for: top 1-20% popular, static assets, new releases.</p>

            <p><strong>Hybrid (reality):</strong> 80/20 rule - PUSH top 20% (covers 80% requests), PULL bottom 80% (covers 20% requests). Netflix: PUSH new releases/trending, PULL obscure documentaries. E-commerce: PUSH homepage/bestsellers, PULL user reviews/long-tail.</p>

            <h3>Decision Matrix</h3>
            <table>
                <thead>
                    <tr>
                        <th>Content Type</th>
                        <th>Popularity</th>
                        <th>Change Frequency</th>
                        <th>Strategy</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Company logo</td>
                        <td>High</td>
                        <td>Never</td>
                        <td>PUSH</td>
                    </tr>
                    <tr>
                        <td>Homepage CSS</td>
                        <td>High</td>
                        <td>Weekly</td>
                        <td>PUSH</td>
                    </tr>
                    <tr>
                        <td>Product image</td>
                        <td>Medium</td>
                        <td>Rare</td>
                        <td>PUSH (bestseller) / PULL (not)</td>
                    </tr>
                    <tr>
                        <td>User avatar</td>
                        <td>Low</td>
                        <td>Often</td>
                        <td>PULL</td>
                    </tr>
                    <tr>
                        <td>API response</td>
                        <td>N/A</td>
                        <td>Real-time</td>
                        <td>Don't cache</td>
                    </tr>
                </tbody>
            </table>

            <h2>Cache Key Design</h2>

            <p>Unique identifier for cached content. Determines if two requests get same content. Simple: <code>cache_key = URL</code>. Complex: include headers (device type, encoding, language).</p>

            <pre><code>def generate_cache_key(url, headers):
    key_parts = [url]
    for header in ['Accept-Encoding', 'User-Agent']:
        if header in headers:
            key_parts.append(f"{header}:{headers[header]}")
    return hashlib.md5('|'.join(key_parts).encode()).hexdigest()</code></pre>

            <p><strong>Pitfalls:</strong> Too specific → low hit ratio. Too broad → serve wrong content (mobile gets desktop). Query params: <code>image.jpg?user=123</code> → don't cache (per-user). <code>image.jpg?v=2</code> → cache (versioning).</p>

            <h2>Key Takeaways</h2>
            <ul>
                <li>Multi-tier: 90% × 85% = 1.5% origin hits (Origin Shield de-duplicates requests)</li>
                <li>DNS routing + health checks = automatic failover (TTL delay caveat)</li>
                <li>Hybrid wins: PUSH popular (20%), PULL long tail (80%)</li>
                <li>Cache keys determine correctness - balance specificity vs hit ratio</li>
            </ul>

            <div style="margin-top: 40px; padding-top: 15px; border-top: 2px solid #000000; text-align: center;">
                <a href="../index.html" class="back-link">back to all posts</a>
            </div>
        </div>
    </div>
</body>
</html>
